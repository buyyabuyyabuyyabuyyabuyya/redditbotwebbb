import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs';
import { createServerSupabaseClient } from '../../../../utils/supabase-server';
import { createClient } from '@supabase/supabase-js';
import { publishQStashMessage, scheduleQStashMessage } from '../../../../utils/qstash';
import snoowrap from 'snoowrap';
import { ensureInboxSchedule } from '../../../../utils/inboxScheduler';
import { checkAndArchiveLogs } from '../auto-archive-helper';
import { logAntiBanEvent, validateMessageSafety } from '../../../../utils/antiBan';

// Create admin client for bypassing RLS
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || ''
);

export async function POST(req: Request) {
  try {
    const internal =
      req.headers.get('X-Internal-API') === 'true' ||
      req.headers.has('Upstash-Signature');
    const authRes = await auth();
    let userId = authRes?.userId || null;
    if (!internal && !userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { configId, remaining: remainingInput, after: afterCursor } = (await req.json()) as {
      configId: string;
      remaining?: number;
      after?: string;
    };

    // Regular client (respecting RLS) + admin client (bypass)
    const supabase = createServerSupabaseClient();

    // Fetch scan config with anti-ban settings
    const { data: config, error: cfgErr } = await supabaseAdmin
      .from('scan_configs')
      .select(`*, message_templates(*), reddit_accounts(*)`)
      .eq('id', configId)
      .single();

    if (cfgErr || !config) {
      return NextResponse.json(
        { error: 'Config not found' },
        { status: 404 }
      );
    }

    // Ensure we have a userId (fallback to config owner for internal calls)
    if (!userId) {
      userId = config.user_id;
    }

    let remaining = remainingInput ?? 100;

    // ----- Quota enforcement -----
    const { data: userRow } = await supabaseAdmin
      .from('users')
      .select('subscription_status, message_count')
      .eq('id', userId)
      .single();
    
    const planStatus = userRow?.subscription_status || 'free';
    const PLAN_LIMITS: Record<string, number | null> = { free: 15, pro: 200, advanced: null };
    const planLimit = Object.prototype.hasOwnProperty.call(PLAN_LIMITS, planStatus)
      ? PLAN_LIMITS[planStatus]
      : 15;
    
    let quotaRemaining: number | null = null;
    if (planLimit !== null) {
      const used = userRow?.message_count || 0;
      quotaRemaining = Math.max(0, planLimit - used);
      
      if (quotaRemaining === 0) {
        await supabaseAdmin.from('bot_logs').insert({
          user_id: userId,
          config_id: configId,
          action: 'quota_reached',
          status: 'error',
          details: { plan: planStatus, used, limit: planLimit },
          created_at: new Date().toISOString(),
        });
        
        return NextResponse.json({ queued: false, reason: 'quota_reached' });
      }
      remaining = Math.min(remaining, quotaRemaining);
    }

    // Fetch Reddit account details
    const { data: account } = await supabaseAdmin
      .from('reddit_accounts')
      .select('access_token, refresh_token, username')
      .eq('id', config.reddit_account_id)
      .single();

    if (!account) {
      return NextResponse.json({ error: 'Reddit account not found' }, { status: 404 });
    }

    // Get anti-ban configuration
    const antiBanConfig = {
      baseDelayMinutes: config.base_delay_minutes || 5,
      maxMessagesPerHour: config.max_messages_per_hour || 10,
      enableJitter: config.enable_jitter !== false,
      enableUserHistoryCheck: config.enable_user_history_check !== false,
      enableSubredditLimits: config.enable_subreddit_limits !== false,
      enableLongPauses: config.enable_long_pauses !== false,
      conservativeMode: config.conservative_mode || false,
    };

    // Initialize Snoowrap
    const snoowrap = new snoowrap({
      userAgent: 'RedditBotSaaS/1.0',
      clientId: process.env.REDDIT_CLIENT_ID,
      clientSecret: process.env.REDDIT_CLIENT_SECRET,
      refreshToken: account.refresh_token,
      accessToken: account.access_token,
    });

    // Fetch posts from Reddit
    let posts: any[] = [];
    try {
      const subreddit = snoowrap.getSubreddit(config.subreddit);
      posts = await subreddit.getNew({ limit: Math.min(remaining, 25) });
    } catch (error) {
      console.error('Error fetching posts:', error);
      return NextResponse.json({ error: 'Failed to fetch posts' }, { status: 500 });
    }

    if (posts.length === 0) {
      return NextResponse.json({ queued: false, reason: 'No posts found' });
    }

    // Filter posts based on keywords
    const keywords = config.keywords?.split(',').map((k: string) => k.trim().toLowerCase()) || [];
    const filteredPosts = posts.filter((post: any) => {
      const title = post.title?.toLowerCase() || '';
      const selftext = post.selftext?.toLowerCase() || '';
      return keywords.some(keyword => title.includes(keyword) || selftext.includes(keyword));
    });

    // Check message history
    const candidatePosts = [];
    const seenAuthors = new Set();

    for (const post of filteredPosts) {
      if (!post.author || seenAuthors.has(post.author.name)) continue;

      // Check if already messaged this user
      const { data: existingMsg } = await supabaseAdmin
        .from('sent_messages')
        .select('id')
        .eq('user_id', userId)
        .eq('account_id', config.reddit_account_id)
        .eq('recipient', post.author.name)
        .eq('subreddit', config.subreddit)
        .eq('post_id', post.id)
        .maybeSingle();

      if (existingMsg) continue;

      // Check user history if enabled
      if (antiBanConfig.enableUserHistoryCheck) {
        const { data: previousMessages } = await supabaseAdmin
          .from('sent_messages')
          .select('id')
          .eq('user_id', userId)
          .eq('recipient', post.author.name)
          .gte('sent_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())
          .limit(1);

        if (previousMessages && previousMessages.length > 0) {
          logAntiBanEvent('user_history_block', {
            recipient: post.author.name,
            reason: 'messaged_within_24h',
            configId
          });
          continue;
        }
      }

      // Check subreddit limits if enabled
      if (antiBanConfig.enableSubredditLimits) {
        const { data: subredditMessages } = await supabaseAdmin
          .from('sent_messages')
          .select('id')
          .eq('user_id', userId)
          .eq('subreddit', config.subreddit)
          .gte('sent_at', new Date(Date.now() - 60 * 60 * 1000).toISOString()); // Last hour

        if (subredditMessages && subredditMessages.length >= antiBanConfig.maxMessagesPerHour) {
          logAntiBanEvent('subreddit_limit_block', {
            subreddit: config.subreddit,
            limit: antiBanConfig.maxMessagesPerHour,
            configId
          });
          continue;
        }
      }

      candidatePosts.push(post);
      seenAuthors.add(post.author.name);
    }

    if (candidatePosts.length === 0) {
      return NextResponse.json({ queued: false, reason: 'No new posts' });
    }

    // Calculate delays based on anti-ban configuration
    const baseDelayMs = antiBanConfig.baseDelayMinutes * 60 * 1000;
    const maxMessages = Math.min(candidatePosts.length, remaining);

    // Ensure recurring inbox job exists
    const baseUrl =
      process.env.NEXT_PUBLIC_SITE_URL ||
      process.env.NEXT_PUBLIC_VERCEL_URL ||
      process.env.VERCEL_URL || '';
    
    if (baseUrl) {
      const fullOrigin = baseUrl.startsWith('http') ? baseUrl : `https://${baseUrl}`;
      ensureInboxSchedule(config.user_id, fullOrigin);
      
      try {
        await publishQStashMessage({
          destination: `${fullOrigin}/api/reddit/process-inbox`,
          body: { userId: config.user_id },
          delayMs: 7000,
        });
      } catch (err) {
        console.error('failed to queue immediate inbox check', err);
      }
    }

    // Schedule messages with anti-ban delays
    const nowSec = Math.floor(Date.now() / 1000);
    const consumerUrl = `${baseUrl}/api/reddit/send-message`;

    for (let i = 0; i < maxMessages; i++) {
      const post = candidatePosts[i];
      
      // Calculate dynamic delay
      let delay = baseDelayMs;
      
      // Add progressive delay for consecutive messages
      delay += (i * 60000); // Add 1 minute per consecutive message
      
      // Add jitter if enabled
      if (antiBanConfig.enableJitter) {
        const jitter = (Math.random() - 0.5) * 180000; // Â±3 minutes
        delay += jitter;
      }
      
      // Conservative mode increases delays
      if (antiBanConfig.conservativeMode) {
        delay *= 1.5;
      }
      
      // Ensure minimum delay
      delay = Math.max(delay, 180000); // Minimum 3 minutes
      
      const notBefore = nowSec + Math.floor(delay / 1000);

      logAntiBanEvent('message_scheduled', {
        delayMs: delay,
        recipient: post.author.name,
        subreddit: config.subreddit,
        postId: post.id,
        configId
      });

      await scheduleQStashMessage({
        destination: consumerUrl,
        body: { 
          configId, 
          postId: post.id,
          antiBanConfig: {
            baseDelayMinutes: antiBanConfig.baseDelayMinutes,
            enableUserHistoryCheck: antiBanConfig.enableUserHistoryCheck,
            enableSubredditLimits: antiBanConfig.enableSubredditLimits,
            conservativeMode: antiBanConfig.conservativeMode
          }
        },
        notBefore,
      });
    }

    return NextResponse.json({ 
      queued: true, 
      count: maxMessages,
      antiBanConfig: {
        baseDelayMinutes: antiBanConfig.baseDelayMinutes,
        maxMessagesPerHour: antiBanConfig.maxMessagesPerHour,
        conservativeMode: antiBanConfig.conservativeMode
      }
    });

  } catch (error) {
    console.error('Error in scan-start:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
